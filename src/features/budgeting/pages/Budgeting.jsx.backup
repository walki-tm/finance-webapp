// src/features/budgeting/pages/Budgeting.jsx
import React, { useMemo, useState, useEffect } from 'react';
import { Card, CardContent } from '../../ui';
import { MAIN_CATS, months } from '../../../lib/constants.js';
import { nice } from '../../../lib/utils.js';
import SvgIcon from '../../icons/components/SvgIcon.jsx';
import BudgetTable from '../components/BudgetTable.jsx';
import { buildCtxFromState, selectBudgetRows } from '../lib';
import EditableCell from '../components/EditableCell.jsx';
import TotalCell from '../components/TotalCell.jsx';
import BudgetRowActions from '../components/BudgetRowActions.jsx';

// helper utili
const CORE = new Set(['income', 'expense', 'debt', 'saving']);
const MONTH_INDEXES = Array.from({ length: 12 }, (_, i) => i); // 0..11

// colore con alpha
function hexToRgba(hex, a = 1) {
  const h = String(hex || '#000000').replace('#','');
  const v = h.length === 3 ? h.split('').map(c=>c+c).join('') : h;
  const r = parseInt(v.slice(0,2), 16);
  const g = parseInt(v.slice(2,4), 16);
  const b = parseInt(v.slice(4,6), 16);
  return `rgba(${r},${g},${b},${a})`;
}
const isDark = () => typeof document !== 'undefined' && document.documentElement.classList.contains('dark');

function monthKey(date) {
  const d = new Date(date);
  return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`;
}

export default function Budgeting({ state, year, upsertBudget, batchUpsertBudgets }) {
  const [selMain, setSelMain] = useState('expense');
  const [mode, setMode] = useState('year'); // 'year' | 'month'
  const [viewMode, setViewMode] = useState('semester1'); // 'semester1' | 'semester2' | 'all'
  const [darkMode, setDarkMode] = useState(() => isDark());
  const [autoSaveStatus, setAutoSaveStatus] = useState('saved'); // 'saving' | 'saved' | 'error'
  const [lastSaveTime, setLastSaveTime] = useState(null);
  const today = new Date();
  const defaultMonth = useMemo(() => {
    const y = Number(year);
    if (today.getFullYear() !== y) return 0;
    const m = today.getMonth();
    const d = today.getDate();
    return d >= 15 ? Math.min(m + 1, 11) : m; // dal 15 passa al prossimo mese
  }, [year]);
  const [monthIdx, setMonthIdx] = useState(defaultMonth);
  React.useEffect(() => { setMonthIdx(defaultMonth); }, [defaultMonth]);

  // Hook per rilevare cambiamenti tema
  useEffect(() => {
    const observer = new MutationObserver(() => {
      setDarkMode(isDark());
    });
    
    observer.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ['class']
    });

    return () => observer.disconnect();
  }, []);

  // Costruisci elenco main da renderizzare: solo quelli abilitati e che hanno sottocategorie
  const mainsToRender = useMemo(() => {
    const enabled = new Set([
      ...MAIN_CATS.map(m => m.key).filter(k => state.mainEnabled?.[k] !== false),
      ...(state.customMainCats || []).filter(c => state.mainEnabled?.[c.key] !== false).map(c => c.key),
    ]);
    const withSubs = Object.entries(state.subcats || {})
      .filter(([k, arr]) => Array.isArray(arr) && arr.length > 0 && enabled.has(k))
      .map(([k]) => k);
    return withSubs;
  }, [state.customMainCats, state.mainEnabled, state.subcats]);

  // 1) STATISTICHE MENSILI CON BUDGET (solo budget, no transazioni reali)
  const monthlyStats = useMemo(() => {
    const stats = {};
    for (const mi of MONTH_INDEXES) {
      const key = `${year}-${String(mi + 1).padStart(2, '0')}`;
      stats[key] = { 
        budgetTotals: {}, // totali budget per categoria
        budgetPct: {} // percentuali budget
      };
    }

    // Calcola totali budget per ogni mese (SOLO BUDGET, NO TRANSAZIONI)
    for (const mi of MONTH_INDEXES) {
      const key = `${year}-${String(mi + 1).padStart(2, '0')}`;
      const s = stats[key];
      
      // Calcola somme budget per ogni main categoria
      for (const mainKey of mainsToRender) {
        const subs = state.subcats?.[mainKey] || [];
        let mainTotal = 0;
        subs.forEach(sub => {
          const budgetValue = Number(state.budgets[year]?.[`${mainKey}:${sub.name}:${mi}`] || 0);
          mainTotal += budgetValue;
        });
        s.budgetTotals[mainKey] = mainTotal;
      }

      // CALCOLO DA ALLOCARE: Budget Reddito - Budget delle altre categorie (non reddito)
      const budgetIncome = s.budgetTotals['income'] || 0;
      const totalBudgetExpenses = Object.entries(s.budgetTotals)
        .filter(([mainKey]) => mainKey !== 'income') // ESCLUDI income dalla sottrazione
        .reduce((sum, [, val]) => sum + Math.abs(val), 0);
      
      s.toAllocate = budgetIncome - totalBudgetExpenses;
      
      const pct = (x) => budgetIncome > 0 ? Math.round((Math.abs(x) / budgetIncome) * 100) : 0;
      
      // Percentuali basate sui budget del reddito
      Object.entries(s.budgetTotals).forEach(([mainKey, total]) => {
        if (mainKey !== 'income') { // Solo per le categorie di spesa
          s.budgetPct[mainKey] = pct(total);
        }
      });
    }
    return stats;
  }, [state.budgets, state.subcats, mainsToRender, year]);

  // mains custom note (per intestare le righe in alto)
  const customMains = useMemo(() => {
    const byKey = new Set(
      (state.customMainCats || [])
        .filter(c => state.mainEnabled?.[c.key] !== false)
        .map(c => c.key)
    );
    return Array.from(byKey);
  }, [state.customMainCats, state.mainEnabled]);

  // ---- Helper: recupera metadati colore/nome per una main (core o custom)
  const mainMeta = (key) => {
    // Prima prova a leggere override dal DB (presenti in customMainCats anche per le core)
    const c = (state.customMainCats || []).find(x => x.key === key);
    if (c) return { name: c.name || key.toUpperCase(), color: c.color || '#64748b' };
    // Fallback ai default statici
    const core = MAIN_CATS.find(m => m.key === key);
    if (core) return { name: core.name, color: core.color };
    return { name: key.toUpperCase(), color: '#64748b' };
  };

  // Determina quali mesi mostrare in base alla view mode
  const visibleMonths = useMemo(() => {
    switch (viewMode) {
      case 'semester1':
        return [0, 1, 2, 3, 4, 5]; // Gen-Giu
      case 'semester2':
        return [6, 7, 8, 9, 10, 11]; // Lug-Dic
      default:
        return MONTH_INDEXES; // tutti i 12 mesi
    }
  }, [viewMode]);

  // Helper per ottenere status del mese
  const getMonthStatus = (toAllocate) => {
    if (toAllocate < 0) return { status: 'over', icon: 'âš ï¸', color: '#ef4444', bgColor: '#fef2f2' };
    if (toAllocate > 0) return { status: 'unallocated', icon: 'ðŸ’°', color: '#f59e0b', bgColor: '#fffbeb' };
    return { status: 'balanced', icon: 'âœ…', color: '#10b981', bgColor: '#f0fdf4' };
  };

  // Calcola statistiche per il riepilogo cards
  const summaryStats = useMemo(() => {
    const currentMonth = today.getMonth();
    const currentMonthKey = `${year}-${String(currentMonth + 1).padStart(2, '0')}`;
    const currentStats = monthlyStats[currentMonthKey];
    
    // Da allocare del mese corrente
    const currentToAllocate = currentStats?.toAllocate || 0;
    
    // Media da allocare dell'anno
    const yearlyAverage = MONTH_INDEXES.reduce((sum, i) => {
      const key = `${year}-${String(i + 1).padStart(2, '0')}`;
      return sum + (monthlyStats[key]?.toAllocate || 0);
    }, 0) / 12;
    
    // Top categorie per percentuale media - includiamo anche quelle con 0% per mostrare struttura
    const allCategories = mainsToRender
      .filter(key => key !== 'income')
      .map(key => {
        const meta = mainMeta(key);
        const avgPercentage = MONTH_INDEXES.reduce((sum, i) => {
          const monthKey = `${year}-${String(i + 1).padStart(2, '0')}`;
          return sum + (monthlyStats[monthKey]?.budgetPct?.[key] || 0);
        }, 0) / 12;
        const avgAmount = MONTH_INDEXES.reduce((sum, i) => {
          const monthKey = `${year}-${String(i + 1).padStart(2, '0')}`;
          return sum + (monthlyStats[monthKey]?.budgetTotals?.[key] || 0);
        }, 0) / 12;
        return { key, meta, avgPercentage: Math.round(avgPercentage), avgAmount: Math.round(avgAmount) };
      })
      .sort((a, b) => b.avgPercentage - a.avgPercentage);
    
    // Se non ci sono categorie con percentuali > 0, mostra comunque le prime 3 disponibili
    const topCategories = allCategories.length > 0 ? allCategories.slice(0, 3) : [];
    
    return {
      currentToAllocate,
      yearlyAverage: Math.round(yearlyAverage),
      topCategories,
      currentMonthName: months[currentMonth],
      hasData: allCategories.length > 0
    };
  }, [monthlyStats, year, mainsToRender, mainMeta, today]);

  // Calcola mappa valori per mese per (main, sub)
  const mapMainSubPerMonth = useMemo(() => {
    const map = {}; // main -> sub -> {0..11}
    for (const main of mainsToRender) {
      const subs = state.subcats?.[main] || [];
      if (!subs.length) continue;
      map[main] = {};
      subs.forEach(sc => { map[main][sc.name] = Object.fromEntries(MONTH_INDEXES.map(i => [i, 0])); });
    }
    state.transactions.forEach(t => {
      const d = new Date(t.date);
      if (d.getFullYear() !== Number(year)) return;
      const main = String(t.main);
      if (!map[main]) return;
      const m = d.getMonth();
      const subName = t.sub || t.subName || t.subname || t.subcategory?.name || t.Subcategory?.name;
      if (subName && map[main][subName] != null) {
        map[main][subName][m] += Number(t.amount) || 0;
      }
    });
    return map;
  }, [state.transactions, state.subcats, mainsToRender, year]);

  // Vista mensile (beta) con nuova tabella
  const periodMonthKey = useMemo(() => `${year}-${String(monthIdx + 1).padStart(2,'0')}`, [year, monthIdx]);
  const compatCtx = useMemo(() => buildCtxFromState(state, year), [state, year]);
  const monthRows = useMemo(() => selectBudgetRows({ period: periodMonthKey, ...compatCtx, prorataMode: 'equal' }), [periodMonthKey, compatCtx]);

  // Ottimizzazione: wrapped upsert con auto-save feedback
  const optimizedUpsertBudget = React.useCallback(async (main, keyWithMonth, value) => {
    setAutoSaveStatus('saving');
    setLastSaveTime(Date.now());
    try {
      await upsertBudget(main, keyWithMonth, value);
      setAutoSaveStatus('saved');
    } catch (error) {
      console.error('Error saving budget:', error);
      setAutoSaveStatus('error');
    }
  }, [upsertBudget]);

  // Ottimizzazione: wrapped batch upsert con auto-save feedback
  const optimizedBatchUpsertBudgets = React.useCallback(async (updates) => {
    setAutoSaveStatus('saving');
    setLastSaveTime(Date.now());
    try {
      await batchUpsertBudgets(updates);
      setAutoSaveStatus('saved');
    } catch (error) {
      console.error('Error batch saving budgets:', error);
      setAutoSaveStatus('error');
    }
  }, [batchUpsertBudgets]);

  async function handleUpdateCell(period, categoryKey, patch) {
    if (!patch || typeof patch.amount !== 'number') return;
    const y = Number(period.slice(0,4));
    const m = Number(period.slice(5,7)) - 1; // 0..11
    const [main, sub] = String(categoryKey).split(':');
    if (!main || !sub) return;
    await optimizedUpsertBudget(main, `${sub}:${m}`, Number(patch.amount) || 0);
  }

  return (
    <div className="space-y-6 pb-20"> {/* Extra padding bottom for context menus */}


      {/* SEZIONE ALTA: RIEPILOGO SMART CARDS */}
      <div className="space-y-6">
        {/* Header e Cards principali */}
        <div className="space-y-4">
          <div className="flex items-center justify-between">
            <h2 className="text-xl font-bold text-slate-900 dark:text-slate-100">ðŸ“Š Riepilogo Budget</h2>
            <div className="text-sm text-slate-500 dark:text-slate-400">
              Anno {year} â€¢ {summaryStats.currentMonthName}
            </div>
          </div>
          
          {/* Cards principali */}
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
            {/* Card Da Allocare */}
            <Card className="border-l-4 border-l-blue-500 shadow-md hover:shadow-lg transition-shadow duration-200">
              <CardContent className="p-6">
                <div className="flex items-center justify-between mb-4">
                  <div className="flex items-center gap-2">
                    <span className="text-2xl">{getMonthStatus(summaryStats.currentToAllocate).icon}</span>
                    <div>
                      <h3 className="font-semibold text-slate-700 dark:text-slate-200">Da Allocare</h3>
                      <p className="text-xs text-slate-500">{summaryStats.currentMonthName}</p>
                    </div>
                  </div>
                </div>
                <div className="space-y-2">
                  <div className="text-2xl font-bold" style={{ color: getMonthStatus(summaryStats.currentToAllocate).color }}>
                    {Math.abs(summaryStats.currentToAllocate).toLocaleString('it-IT')}â‚¬
                  </div>
                  <div className="text-xs text-slate-500">
                    Media anno: {Math.abs(summaryStats.yearlyAverage).toLocaleString('it-IT')}â‚¬
                  </div>
                </div>
              </CardContent>
            </Card>
            
            {/* Cards Top Categorie */}
            {summaryStats.topCategories.length > 0 ? (
              summaryStats.topCategories.slice(0, 3).map((cat, idx) => (
                <Card key={cat.key} className={`shadow-md hover:shadow-lg transition-shadow duration-200 ${
                  idx === 0 ? 'border-l-4' : 'border-l-2'
                }`} style={{ borderLeftColor: cat.meta.color }}>
                  <CardContent className="p-6">
                    <div className="flex items-center justify-between mb-4">
                      <div className="flex items-center gap-2">
                        <div className="w-3 h-3 rounded-full" style={{ backgroundColor: cat.meta.color }}></div>
                        <div>
                          <h3 className="font-semibold text-slate-700 dark:text-slate-200 text-sm">
                            {cat.meta.name}
                          </h3>
                          <p className="text-xs text-slate-500">Media mensile</p>
                        </div>
                      </div>
                      {idx === 0 && (
                        <span className="text-xs bg-yellow-100 dark:bg-yellow-900/30 text-yellow-800 dark:text-yellow-300 px-2 py-1 rounded-full font-medium">
                          Top
                        </span>
                      )}
                    </div>
                    <div className="space-y-2">
                      <div className="text-2xl font-bold" style={{ color: cat.meta.color }}>
                        {cat.avgPercentage}%
                      </div>
                      <div className="text-xs text-slate-500">
                        {cat.avgAmount.toLocaleString('it-IT')}â‚¬ / mese
                      </div>
                    </div>
                  </CardContent>
                </Card>
              ))
            ) : (
              // Cards placeholder quando non ci sono categorie
              Array.from({ length: 3 }, (_, idx) => (
                <Card key={`placeholder-${idx}`} className="shadow-md border-l-2 border-l-slate-300 dark:border-l-slate-600">
                  <CardContent className="p-6">
                    <div className="flex items-center justify-between mb-4">
                      <div className="flex items-center gap-2">
                        <div className="w-3 h-3 rounded-full bg-slate-300 dark:bg-slate-600"></div>
                        <div>
                          <h3 className="font-semibold text-slate-500 dark:text-slate-400 text-sm">
                            Categoria {idx + 1}
                          </h3>
                          <p className="text-xs text-slate-400">Non configurata</p>
                        </div>
                      </div>
                    </div>
                    <div className="space-y-2">
                      <div className="text-2xl font-bold text-slate-400">
                        0%
                      </div>
                      <div className="text-xs text-slate-400">
                        0â‚¬ / mese
                      </div>
                    </div>
                  </CardContent>
                </Card>
              ))
            )}
          </div>
        </div>
        
        {/* Riepilogo dettagliato collassabile */}
        <Card className="shadow-lg shadow-slate-200/50 dark:shadow-slate-800/50">
          <CardContent>
            <details className="group">
              <summary className="flex items-center justify-between cursor-pointer p-2 rounded-lg hover:bg-slate-50 dark:hover:bg-slate-800/50 transition-colors">
                <div className="flex items-center gap-2">
                  <span className="text-lg font-semibold text-slate-700 dark:text-slate-200">ðŸ“‹ Dettaglio Mensile</span>
                  <span className="text-xs text-slate-500 bg-slate-100 dark:bg-slate-800 px-2 py-1 rounded-full">
                    Click per espandere
                  </span>
                </div>
                <div className="text-slate-400 group-open:rotate-180 transition-transform duration-200">
                  â–¼
                </div>
              </summary>
              
              <div className="mt-4 rounded-xl border border-slate-200/20 shadow-md shadow-slate-100/30 dark:shadow-slate-800/30">
                {/* Header con griglia responsive */}
                <div className="bg-slate-100 dark:bg-slate-800 p-4 rounded-t-xl">
                  <div className="grid grid-cols-13 gap-2 text-sm font-semibold">
                    <div className="text-left col-span-2 lg:col-span-1">Voce</div>
                    {MONTH_INDEXES.map(i => (
                      <div key={i} className="text-center text-xs lg:text-sm">
                        {months[i].substring(0, 3).toUpperCase()}
                      </div>
                    ))}
                  </div>
                </div>
                
                {/* Contenuto con griglia responsive */}
                <div className="p-4 space-y-3">
                  {/* Da allocare */}
                  <div className="grid grid-cols-13 gap-2 py-2 border-b border-slate-200/10">
                    <div className="col-span-2 lg:col-span-1 font-semibold text-sm" style={{ color: mainMeta('income').color }}>Da allocare</div>
                    {MONTH_INDEXES.map(i => {
                      const key = `${year}-${String(i + 1).padStart(2, '0')}`;
                      const monthStat = monthlyStats[key];
                      const toAllocate = monthStat?.toAllocate || 0;
                      const status = getMonthStatus(toAllocate);
                      
                      return (
                        <div key={i} className="text-center font-semibold text-sm" data-month={months[i].substring(0, 3).toUpperCase()}>
                          {toAllocate !== 0 && (
                            <div className="flex flex-col items-center gap-1">
                              <span className="text-xs">{status.icon}</span>
                              <span style={{ color: status.color }}>
                                {toAllocate > 0 
                                  ? `${Math.round(toAllocate).toLocaleString('it-IT')}â‚¬`
                                  : `${Math.round(Math.abs(toAllocate)).toLocaleString('it-IT')}â‚¬`
                                }
                              </span>
                            </div>
                          )}
                        </div>
                      );
                    })}
                  </div>
                  
                  {/* Percentuali per ogni main presente */}
                  {mainsToRender
                    .filter(key => key !== 'income') // escludi income
                    .map(key => {
                      const meta = mainMeta(key);
                      return (
                        <div key={key} className="grid grid-cols-13 gap-2 py-2 border-b border-slate-200/10">
                          <div className="col-span-2 lg:col-span-1 text-sm flex items-center gap-2">
                            <span style={{ color: meta.color }}>
                              % {meta.name.toLowerCase()}
                            </span>
                          </div>
                          {MONTH_INDEXES.map(i => {
                            const monthKey = `${year}-${String(i + 1).padStart(2, '0')}`;
                            const monthStat = monthlyStats[monthKey];
                            const percentage = monthStat?.budgetPct?.[key] || 0;
                            return (
                              <div 
                                key={i} 
                                className="text-center font-semibold text-xs" 
                                style={{ color: meta.color }}
                                data-month={months[i].substring(0, 3).toUpperCase()}
                              >
                                {percentage === 0 ? '' : `${percentage}%`}
                              </div>
                            );
                          })}
                        </div>
                      );
                    })}
                </div>
              </div>
            </details>
          </CardContent>
        </Card>
      </div>

      {/* CONTROLLI NAVIGAZIONE SEMESTRE CON FRECCE */}
      <div className="flex justify-center mb-6">
        <Card className="shadow-lg">
          <CardContent className="p-4">
            <div className="flex items-center justify-center gap-4">
              {/* Freccia sinistra */}
              <button
                onClick={() => setViewMode('semester1')}
                disabled={viewMode === 'semester1'}
                className={`p-2 rounded-lg transition-all duration-200 ${
                  viewMode === 'semester1'
                    ? 'text-slate-400 cursor-not-allowed'
                    : 'text-slate-600 hover:text-blue-600 hover:bg-blue-50 dark:text-slate-400 dark:hover:text-blue-400 dark:hover:bg-blue-900/20'
                }`}
                title="Precedente (Gennaio-Giugno)"
              >
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
                </svg>
              </button>
              
              {/* Visualizzazione corrente */}
              <div className="text-center min-w-[120px]">
                <div className="text-lg font-bold text-slate-800 dark:text-slate-200">
                  {viewMode === 'semester1' ? 'GEN - GIU' : 'LUG - DIC'}
                </div>
                <div className="text-xs text-slate-500 mt-1">
                  {viewMode === 'semester1' ? 'Primo Semestre' : 'Secondo Semestre'}
                </div>
              </div>
              
              {/* Freccia destra */}
              <button
                onClick={() => setViewMode('semester2')}
                disabled={viewMode === 'semester2'}
                className={`p-2 rounded-lg transition-all duration-200 ${
                  viewMode === 'semester2'
                    ? 'text-slate-400 cursor-not-allowed'
                    : 'text-slate-600 hover:text-blue-600 hover:bg-blue-50 dark:text-slate-400 dark:hover:text-blue-400 dark:hover:bg-blue-900/20'
                }`}
                title="Successivo (Luglio-Dicembre)"
              >
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                </svg>
              </button>
            </div>
          </CardContent>
        </Card>
      </div>

      {/* SEZIONE BASSA: UN FORM PER OGNI MAIN (core + custom con sottocategorie) */}
      {mainsToRender.map(mainKey => {
        const subs = state.subcats?.[mainKey] || [];
        if (!subs.length) return null; // salta se non ci sono sottocategorie
        const { name, color } = mainMeta(mainKey);
        const rowsActual = mapMainSubPerMonth[mainKey] || {};
        const planFor = (sub, i) => Number(state.budgets[year]?.[`${mainKey}:${sub}:${i}`] || 0);
        const dark = isDark();
        const cardBg = hexToRgba(color, dark ? 0.08 : 0.06);
        const cardBorder = hexToRgba(color, dark ? 0.35 : 0.25);
        const headBg = hexToRgba(color, dark ? 0.20 : 0.12);
        
        // Calcola totali semestri
        const semester1Total = MONTH_INDEXES.slice(0, 6).reduce((sum, i) => {
          return sum + subs.reduce((subSum, sc) => subSum + planFor(sc.name, i), 0);
        }, 0);
        const semester2Total = MONTH_INDEXES.slice(6, 12).reduce((sum, i) => {
          return sum + subs.reduce((subSum, sc) => subSum + planFor(sc.name, i), 0);
        }, 0);
        const yearTotal = semester1Total + semester2Total;
        
        return (
          <div key={mainKey}>
            {/* Card con layout fisso per evitare sovrapposizioni */}
            <Card style={{ borderColor: cardBorder, backgroundColor: cardBg }} className="border">
              <CardContent className="p-6">
                <div className="font-semibold mb-4" style={{ color }}>{name.toUpperCase()}</div>
                
                {/* Vista Desktop - Due tabelle affiancate */}
                <div className="hidden lg:block">
                  <div className="flex gap-0">
                    {/* Tabella principale dei mesi */}
                    <div className="flex-1">
                      <div className="overflow-x-auto rounded-l-lg border-l border-t border-b" style={{ borderColor: cardBorder }}>
                        <table className="w-full table-auto">
                          <thead style={{ backgroundColor: headBg }}>
                            <tr>
                              <th className="text-left p-3" style={{ color, minWidth: '160px' }}>Sottocategoria</th>
                              {visibleMonths.map(i => (
                                <th key={i} className="text-center px-3 py-3 whitespace-nowrap" style={{ color, minWidth: '90px' }}>
                                  {months[i].toUpperCase()}
                                </th>
                              ))}
                            </tr>
                          </thead>
                          <tbody>
                            {subs.map((sc, idx) => {
                              const totalPlanned = MONTH_INDEXES.reduce((a, i) => a + planFor(sc.name, i), 0);
                              const rowBg = hexToRgba(color, isDark() ? 0.22 : 0.12);
                              const rowAltBg = hexToRgba(color, isDark() ? 0.14 : 0.08);
                              
                              const handleSetAllMonths = React.useCallback(async (value) => {
                                if (optimizedBatchUpsertBudgets) {
                                  const updates = MONTH_INDEXES.map(monthIdx => ({
                                    main: mainKey,
                                    keyWithMonth: `${sc.name}:${monthIdx}`,
                                    value
                                  }));
                                  optimizedBatchUpsertBudgets(updates).catch(console.error);
                                } else {
                                  MONTH_INDEXES.forEach(monthIdx => {
                                    optimizedUpsertBudget(mainKey, `${sc.name}:${monthIdx}`, value).catch(console.error);
                                  });
                                }
                              }, [mainKey, sc.name, optimizedBatchUpsertBudgets, optimizedUpsertBudget]);
                              
                              const handleResetAll = React.useCallback(async () => {
                                if (optimizedBatchUpsertBudgets) {
                                  const updates = MONTH_INDEXES.map(monthIdx => ({
                                    main: mainKey,
                                    keyWithMonth: `${sc.name}:${monthIdx}`,
                                    value: 0
                                  }));
                                  optimizedBatchUpsertBudgets(updates).catch(console.error);
                                } else {
                                  MONTH_INDEXES.forEach(monthIdx => {
                                    optimizedUpsertBudget(mainKey, `${sc.name}:${monthIdx}`, 0).catch(console.error);
                                  });
                                }
                              }, [mainKey, sc.name, optimizedBatchUpsertBudgets, optimizedUpsertBudget]);
                              
                              return (
                                <tr 
                                  key={sc.id || sc.name} 
                                  className="border-t" 
                                  style={{ 
                                    borderColor: cardBorder,
                                    backgroundColor: (idx % 2 === 0) ? rowBg : rowAltBg 
                                  }}
                                >
                                  <td className="p-3" style={{ color }}>
                                    <div className="flex items-center gap-2">
                                      <SvgIcon name={sc.iconKey} color={color} size={18} />
                                      <span className="font-semibold text-sm">{sc.name}</span>
                                    </div>
                                  </td>
                                  {visibleMonths.map(i => (
                                    <td key={i} className="px-3 py-2 text-center">
                                      <EditableCell
                                        value={planFor(sc.name, i)}
                                        color={color}
                                        onSave={async (newValue) => {
                                          await optimizedUpsertBudget(mainKey, `${sc.name}:${i}`, newValue);
                                        }}
                                      />
                                    </td>
                                  ))}
                                </tr>
                              );
                            })}
                          </tbody>
                        </table>
                      </div>
                    </div>
                    
                    {/* Tabella separata per totali e azioni */}
                    <div className="w-48 flex-shrink-0">
                      <div className="rounded-r-lg border-r border-t border-b" style={{ borderColor: cardBorder }}>
                        <table className="w-full table-auto">
                          <thead style={{ backgroundColor: headBg }}>
                            <tr>
                              <th className="text-center px-3 py-3" style={{ color, minWidth: '80px' }}>Totale</th>
                              <th className="text-center px-3 py-3" style={{ color, minWidth: '80px' }}>Azioni</th>
                            </tr>
                          </thead>
                          <tbody>
                            {subs.map((sc, idx) => {
                              const totalPlanned = MONTH_INDEXES.reduce((a, i) => a + planFor(sc.name, i), 0);
                              const rowBg = hexToRgba(color, isDark() ? 0.22 : 0.12);
                              const rowAltBg = hexToRgba(color, isDark() ? 0.14 : 0.08);
                              
                              const handleSetAllMonths = async (value) => {
                                if (optimizedBatchUpsertBudgets) {
                                  const updates = MONTH_INDEXES.map(monthIdx => ({
                                    main: mainKey,
                                    keyWithMonth: `${sc.name}:${monthIdx}`,
                                    value
                                  }));
                                  optimizedBatchUpsertBudgets(updates).catch(console.error);
                                } else {
                                  MONTH_INDEXES.forEach(monthIdx => {
                                    optimizedUpsertBudget(mainKey, `${sc.name}:${monthIdx}`, value).catch(console.error);
                                  });
                                }
                              };
                              
                              const handleResetAll = async () => {
                                if (optimizedBatchUpsertBudgets) {
                                  const updates = MONTH_INDEXES.map(monthIdx => ({
                                    main: mainKey,
                                    keyWithMonth: `${sc.name}:${monthIdx}`,
                                    value: 0
                                  }));
                                  optimizedBatchUpsertBudgets(updates).catch(console.error);
                                } else {
                                  MONTH_INDEXES.forEach(monthIdx => {
                                    optimizedUpsertBudget(mainKey, `${sc.name}:${monthIdx}`, 0).catch(console.error);
                                  });
                                }
                              };
                              
                              return (
                                <tr 
                                  key={sc.id || sc.name} 
                                  className="border-t" 
                                  style={{ 
                                    borderColor: cardBorder,
                                    backgroundColor: (idx % 2 === 0) ? rowBg : rowAltBg 
                                  }}
                                >
                                  <td className="px-3 py-2 text-center">
                                    <TotalCell
                                      value={totalPlanned}
                                      color={color}
                                      label={`Totale ${sc.name}`}
                                    />
                                  </td>
                                  <td className="px-3 py-2 text-center">
                                    <BudgetRowActions
                                      color={color}
                                      onSetAllMonths={handleSetAllMonths}
                                      onResetAll={handleResetAll}
                                    />
                                  </td>
                                </tr>
                              );
                            })}
                          </tbody>
                        </table>
                      </div>
                    </div>
                  </div>
                </div>

                {/* Vista Mobile/Tablet - Layout a cards */}
                <div className="lg:hidden">
                  {subs.map((sc, idx) => {
                    const totalPlanned = MONTH_INDEXES.reduce((a, i) => a + planFor(sc.name, i), 0);
                    const rowBg = hexToRgba(color, isDark() ? 0.22 : 0.12);
                    
                    const handleSetAllMonths = async (value) => {
                      // Optimistic update - non aspettare il risultato
                      if (batchUpsertBudgets) {
                        const updates = MONTH_INDEXES.map(monthIdx => ({
                          main: mainKey,
                          keyWithMonth: `${sc.name}:${monthIdx}`,
                          value
                        }));
                        batchUpsertBudgets(updates).catch(console.error);
                      } else {
                        MONTH_INDEXES.forEach(monthIdx => {
                          upsertBudget(mainKey, `${sc.name}:${monthIdx}`, value).catch(console.error);
                        });
                      }
                    };
                    
                    const handleResetAll = async () => {
                      // Optimistic update - non aspettare il risultato
                      if (batchUpsertBudgets) {
                        const updates = MONTH_INDEXES.map(monthIdx => ({
                          main: mainKey,
                          keyWithMonth: `${sc.name}:${monthIdx}`,
                          value: 0
                        }));
                        batchUpsertBudgets(updates).catch(console.error);
                      } else {
                        MONTH_INDEXES.forEach(monthIdx => {
                          upsertBudget(mainKey, `${sc.name}:${monthIdx}`, 0).catch(console.error);
                        });
                      }
                    };
                    
                    return (
                      <div 
                        key={sc.id || sc.name} 
                        className="p-4 border-t" 
                        style={{ 
                          borderColor: cardBorder,
                          backgroundColor: rowBg 
                        }}
                      >
                        {/* Header sottocategoria */}
                        <div className="flex items-center justify-between mb-3">
                          <div className="flex items-center gap-2" style={{ color }}>
                            <SvgIcon name={sc.iconKey} color={color} size={18} />
                            <span className="font-semibold">{sc.name}</span>
                          </div>
                          <BudgetRowActions
                            color={color}
                            onSetAllMonths={handleSetAllMonths}
                            onResetAll={handleResetAll}
                          />
                        </div>
                        
                        {/* Griglia mesi */}
                        <div className="grid grid-cols-3 sm:grid-cols-4 gap-2 mb-3">
                          {MONTH_INDEXES.map(i => (
                            <div key={i} className="bg-white bg-opacity-20 rounded-lg p-2">
                              <div className="text-xs font-medium mb-1" style={{ color, opacity: 0.8 }}>
                                {months[i].substring(0, 3)}
                              </div>
                              <EditableCell
                                value={planFor(sc.name, i)}
                                color={color}
                                onSave={async (newValue) => {
                                  await upsertBudget(mainKey, `${sc.name}:${i}`, newValue);
                                }}
                              />
                            </div>
                          ))}
                        </div>
                        
                        {/* Totale */}
                        <div className="flex justify-between items-center pt-2 border-t" style={{ borderColor: cardBorder }}>
                          <span className="font-medium" style={{ color }}>Totale:</span>
                          <span className="font-bold" style={{ color }}>{Math.round(totalPlanned).toLocaleString('it-IT')}â‚¬</span>
                        </div>
                      </div>
                    );
                  })}
                </div>
              </CardContent>
            </Card>
          </div>
        );
      })}
    </div>
  );
}
