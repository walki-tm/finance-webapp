diff --git a/server/src/routes/transactions.js b/server/src/routes/transactions.js
index 6d805086009ce6ab37f1e5aadedfa5755769c0c8..365a0f75a7e82719479a4131ca7f6dad15d8ad79 100644
--- a/server/src/routes/transactions.js
+++ b/server/src/routes/transactions.js
@@ -1,141 +1,67 @@
 import { Router } from 'express'
-import { prisma } from '../lib/prisma.js'
 import { authRequired } from '../middleware/auth.js'
 import { z } from 'zod'
+import {
+  listTransactions,
+  createTransaction,
+  updateTransaction,
+  deleteTransaction,
+} from '../services/transactionService.js'
 
 const router = Router()
 router.use(authRequired)
 
 const txSchema = z.object({
   date: z.coerce.date(),
   amount: z.coerce.number(),
   main: z.string().min(1).max(32).transform(s => s.toUpperCase()),
   subId: z.string().optional().nullable(),
   note: z.string().optional().nullable(),
   payee: z.string().optional().nullable(),
 })
 
 // PATCH/PUT schema: tutti opzionali
 const txPatchSchema = z.object({
   date: z.string().optional(),
   amount: z.number().optional(),
   // main dinamica: accetta qualsiasi stringa e normalizza in UPPERCASE
   main: z.string().min(1).max(32).transform(s => s.toUpperCase()).optional(),
   subId: z.string().nullable().optional(),
   subName: z.string().nullable().optional(),
   note: z.string().nullable().optional(),
-  payee: z.string().nullable().optional()
+  payee: z.string().nullable().optional(),
 })
 
-router.get('/', async (req, res) => {
-  const userId = req.user.id
-  const { year, month, limit = 200 } = req.query
-
-  const where = { userId }
-  if (year && month) {
-    const y = Number(year), m = Number(month) - 1
-    const from = new Date(Date.UTC(y, m, 1))
-    const to = new Date(Date.UTC(y, m + 1, 1))
-    where.date = { gte: from, lt: to }
-  }
-
-  const data = await prisma.transaction.findMany({
-    where,
-    orderBy: { date: 'desc' },
-    take: Number(limit),
-    include: { subcategory: true }
-  })
-
-  res.json(data)
+router.get('/', async (req, res, next) => {
+  try {
+    const data = await listTransactions(req.user.id, req.query)
+    res.json(data)
+  } catch (e) { next(e) }
 })
 
-router.post('/', async (req, res) => {
-  const userId = req.user.id
+router.post('/', async (req, res, next) => {
   const parsed = txSchema.safeParse(req.body)
   if (!parsed.success) return res.status(400).json({ error: 'Invalid body' })
-
-  let { date, amount, main, subId, subName, note, payee } = parsed.data
-
-  // Risolvi subId da nome se serve
-  if (!subId && subName) {
-    const found = await prisma.subcategory.findFirst({
-      where: { userId, name: { equals: subName, mode: 'insensitive' } },
-      select: { id: true }
-    })
-    if (found) subId = found.id
-  }
-
-  // Valida eventuale subId
-  if (subId) {
-    const ok = await prisma.subcategory.findFirst({ where: { id: subId, userId } })
-    if (!ok) return res.status(400).json({ error: 'Invalid subId' })
-  }
-
-  const created = await prisma.transaction.create({
-    data: {
-      userId,
-      date: new Date(date),
-      amount,
-      main,
-      subId: subId || null,
-      note: note || null,
-      payee: payee || null
-    },
-    include: { subcategory: true }
-  })
-  res.status(201).json(created)
+  try {
+    const created = await createTransaction(req.user.id, parsed.data)
+    res.status(201).json(created)
+  } catch (e) { next(e) }
 })
 
-router.put('/:id', async (req, res) => {
-  const userId = req.user.id
-  const id = req.params.id
-
-  const exists = await prisma.transaction.findFirst({ where: { id, userId } })
-  if (!exists) return res.status(404).json({ error: 'Not found' })
-
+router.put('/:id', async (req, res, next) => {
   const parsed = txPatchSchema.safeParse(req.body)
   if (!parsed.success) return res.status(400).json({ error: 'Invalid body' })
-
-  let { date, amount, main, subId, subName, note, payee } = parsed.data
-
-  // Risolvi subId da nome se serve
-  if (!subId && subName) {
-    const found = await prisma.subcategory.findFirst({
-      where: { userId, name: { equals: subName, mode: 'insensitive' } },
-      select: { id: true }
-    })
-    if (found) subId = found.id
-    else subId = null // se nome non trovato, azzero il link
-  }
-
-  // Valida eventuale subId
-  if (subId) {
-    const ok = await prisma.subcategory.findFirst({ where: { id: subId, userId } })
-    if (!ok) return res.status(400).json({ error: 'Invalid subId' })
-  }
-
-  const updated = await prisma.transaction.update({
-    where: { id },
-    data: {
-      ...(date ? { date: new Date(date) } : {}),
-      ...(typeof amount === 'number' ? { amount } : {}),
-      ...(main ? { main } : {}),
-      ...(subId !== undefined ? { subId } : {}),
-      ...(note !== undefined ? { note } : {}),
-      ...(payee !== undefined ? { payee } : {}),
-    },
-    include: { subcategory: true }
-  })
-  res.json(updated)
+  try {
+    const updated = await updateTransaction(req.user.id, req.params.id, parsed.data)
+    res.json(updated)
+  } catch (e) { next(e) }
 })
 
-router.delete('/:id', async (req, res) => {
-  const userId = req.user.id
-  const id = req.params.id
-  const tx = await prisma.transaction.findFirst({ where: { id, userId } })
-  if (!tx) return res.status(404).json({ error: 'Not found' })
-  await prisma.transaction.delete({ where: { id } })
-  res.status(204).end()
+router.delete('/:id', async (req, res, next) => {
+  try {
+    await deleteTransaction(req.user.id, req.params.id)
+    res.status(204).end()
+  } catch (e) { next(e) }
 })
 
 export default router
